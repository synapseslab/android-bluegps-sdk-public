![BlueGPS Logo](../images/bluegps_logo.svg)

BlueGPS Android SDK
==

## 1. Introduction

This document holds a general guide for the integration of the BlueGPS SDK library into an Android
application. The BlueGPS SDK implements the communication with the BlueGPS server allowing Android
Applications to make use of the system.

*All the data contained in this document are currently under development and may be subject to
change.*

The library use:

- [Kotlin](https://kotlinlang.org/) - First class and official programming language for Android
  development.
- [Coroutines](https://kotlinlang.org/docs/coroutines-guide.html) - A coroutine is a concurrency
  design pattern that you can use on Android to simplify code that executes asynchronously.
- [Retrofit](https://github.com/square/retrofit) - A type-safe HTTP client for Android and Java.
- [Encrypted SharedPreference](https://developer.android.com/topic/security/data) Used to store
  key-value data using encryption.



## 2. Integration guide


### 2.1. Requirements

Minimum requirements are:

- Minimum SDK: 23
- Usage of Android X



### 2.2. Adding the Library to an existing Android application

The BlueGPS Android SDK is distributed through **`Jitpack`**. It can be integrated through gradle, maven as following:

#### Gradle

Before you add BlueGPS depencencies, add it in your `settings.gradle` at the end of repositories

```gradle
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        maven { url = uri("https://jitpack.io") }
    }
}
```

Or if you're using an older project setup, add it in your `build.gradle` at the end of repositories

```gradle
allprojects {
    repositories {
        google()
        mavenCentral()
        maven { url = uri("https://jitpack.io") }
    }
}
```

Then add the dependency for BlueGPS-SDK in the `build.gradle` file for your `app` or module:

```gradle
dependencies {
    implementation 'com.github.synapseslab:android-bluegps-sdk-demoapp:<version>'
}
```



## 3. Getting started

Your first step is initializing the BlueGPSLib, which is the main entry point for all operations in the library. BlueGPSLib is a singleton: you'll create it once and re-use it across your application.

A best practice is to initialize BlueGPSLib in the Application class:

```kotlin
class App : Application() {
    override fun onCreate() {
        super.onCreate()
        
        BlueGPSLib.instance.initSDK(
            sdkEnvironment = Environment.sdkEnvironment,
            context = applicationContext,
        )
    }
}
```



The BlueGSP-SDK use an `Environment` where integrator have to put SDK data for register the SDK and for create a communication with the BlueGPS Server. The management of the environment is demanded to the app.

```kotlin
object Environment {

    private val SDK_ENDPOINT = "{{provided-bluegps-endpoint}}"
    private val APP_ID = "com.synapseslab.demosdk"

    val sdkEnvironment = SdkEnvironment(
        sdkEndpoint = SDK_ENDPOINT,
        appId = APP_ID,
    )
}
```



### App Authentication

The BlueGPS_SDK offers a client for managing authentication and authorization within your application. It leverages Keycloak to handle user authentication.

For the configuration in this case use `keyCloakParameters` parameter on `initSDK(..)`.

```kotlin
BlueGPSLib.instance.initSDK(
    sdkEnvironment = Environment.sdkEnvironment,
    context = applicationContext,
    keyCloakParameters = Environment.keyCloakParameters
)
```

where `keyCloakParameters` is this object

```kotlin
val keyCloakParameters = KeyCloakParameters(
    authorization_endpoint = "https://[BASE-URL]/realms/[REALMS]/protocol/openid-connect/auth",
    token_endpoint = "https://[BASE-URL]/realms/[REALMS]/protocol/openid-connect/token",
    redirect_uri = "{{provided-redirect-uri}}",
    clientId = "{{provided-client-secret}}", // for user authentication
    userinfo_endpoint = "https://[BASE-URL]/realms/[REALMS]/protocol/openid-connect/userinfo",
    end_session_endpoint = "https://[BASE-URL]/realms/[REALMS]/protocol/openid-connect/logout",
    guestClientSecret = "{{provided-guest-client-secret}}", // for guest authentication
    guestClientId = "{{provided-guest-client-id}}" // for guest authentication
)
```


BlueGPS provides 2 kinds of authentication:

- **User Authentication:**
If you want only the User authentication you must set the `clientId`.

This means that for each device this is the user on Keycloak that can manage grants for this particular user.

- **Guest Authentication:**
If you want only the Guest authentication, you must set the `guestClientSecret` and `guestClientId`.

This means that we don't have a user that has to login but we use client credentials and there is not an individual user for each app install. **Instead BlueGPS treats the user account as a "guest" In this case multiple devices can use the same client credentials to be authenticated and BlueGPS will register the user as a device, and not as a formal Keycloak user.**



> **This paramaters are provided by Synapses after the purchase of the BlueGPS license.**



Finally in your ```AndroidManifest.xml``` add this and change host and scheme with your configuration.

```xml
<activity
    android:name="com.synapseslab.bluegps_sdk.authentication.presentation.AuthenticationActivity"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.DEFAULT" />
        <category android:name="android.intent.category.BROWSABLE" />

        <data
            android:host="{HOST}"
            android:scheme="{SCHEME}" />
    </intent-filter>
</activity>
```



## 4. Use BlueGPS Advertising Service

For use the BlueGPS Advertising service, defines callbacks for service binding, passed to `bindService()`

```kotlin
private val advertisingServiceConnection = object : ServiceConnection {

    override fun onServiceConnected(name: ComponentName, service: IBinder) {
        val binder = service as BlueGPSAdvertisingService.LocalBinder
        blueGPSAdvertisingService = binder.serviceBlueGPS
    }

    override fun onServiceDisconnected(name: ComponentName) {
        blueGPSAdvertisingService = null
    }
}
```

Bind to `BlueGPSAdvertisingService` `onStart` method:

```kotlin
override fun onStart() {
    super.onStart()

    val serviceIntent = Intent(this, BlueGPSAdvertisingService::class.java)
    bindService(
        serviceIntent,
        advertisingServiceConnection,
        Context.BIND_AUTO_CREATE
    )
}
```

Clients should unbind from services at appropriate times

```kotlin
override fun onStop() {
    super.onStop()
    unbindService(advertisingServiceConnection)
}
```

For start the advertising call:

```kotlin
blueGPSAdvertisingService?.startAdv()
```

or 

```kotlin
blueGPSAdvertisingService?.startAdv(androidAdvConfiguration = androidAdvConfiguration!!)
```

where `androidAdvConfiguration` a device configuration for advertising as follow:

```kotlin
data class AndroidAdvConfiguration(
    var tagid: String? = null,
    var advModes: String? = null,
    var advTxPowers: String? = null
)
```

For obtain a device configuration for advertising call this function:

```kotlin
suspend fun getDeviceConfiguration(): Resource<AndroidAdvConfiguration>
```

For stop you service advertising call:

```kotlin
blueGPSAdvertisingService?.stopAdv()
```

<br />
<br />

<img src="../images/start_service.png" alt="Start Service" width="300"/>



### 4.1. Optional

If you are interested to receiver logs and display info about the status of the Service,
subclass ``BroadcastReceiver`` and implement the ``onReceive(...)`` method.

The status of the service are: ``STARTED``, ``STOPPED``, ``ERROR``.

```kotlin
private val advertisingServiceReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (intent.action == BlueGPSAdvertisingService.ACTION_ADV) {
                intent.getParcelableExtra<AdvertisingStatus>(BlueGPSAdvertisingService.DATA_ADV)?.let {

                    Log.d(TAG, "- Service ${it.status} ${it.message}")
                }
            }
        }
    }
```

then register the receiver in ``onResume()`` method and unregister the receiver in ``onPause()``
method.

Show the demo example for more details.



## 5 BlueGPSMapView

BlueGPS comes with an handy object to deal with Maps named `BlueGPSMapview`. To use the object you
can import the component in your xml layout or programmatically inflate it.

```xml

<com.synapseslab.bluegps_sdk.component.map.BlueGPSMapView 
    android:id="@+id/webView"
    android:layout_width="match_parent" 
    android:layout_height="match_parent"
    app:layout_constraintBottom_toBottomOf="parent" 
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent" 
    app:layout_constraintTop_toTopOf="parent" />

```

Before can be used, `BlueGPSMapView` should be initialized. Otherwise you will see a loading
animation like below:

<img src="../images/map_view_loading.png" alt="Loading map view" width="300"/>

In order to configure properly the object you need call the `initMap()`

```kotlin
fun initMap(
    sdkEnvironment: SdkEnvironment,
    configurationMap: ConfigurationMap? = ConfigurationMap()
) { 
    ....
}
````

with this parameters:

1. `sdkEnvironment` for authenticate the map;
2. `configurationMap` to config your map, the map start with a default configuration;

```kotlin
private var configurationMap = ConfigurationMap(
    tagid = "CFFF00000001",
    style = MapStyle(
        icons = IconStyle(
            name = "chorus",
            align = "center",
            vAlign = "bottom",
            followZoom = true
        ),
        
        navigation = NavigationStyle(
            iconSource = "/api/public/resource/icons/commons/start.svg",
            iconDestination = "/api/public/resource/icons/commons/end.svg",
            
            // dictionary of target velocity calculation, the velocity is expressed in km/h
            velocityOptions = mutableMapOf("foot" to 4.0, "bike" to 10.0),
            
            // unit in meters to divide the navigation in steps
            navigationStep = 1.5,
            
            // enable or disable autoZoom capability when in navigation mode
            autoZoom = true,
            
            // debug capability to see the steps when in navigation mode
            showVoronoy = false
        )
    ),
    show = ShowMap(all = true, room = true),
)
```

At this point the configuration is injected and the loading animation should disappear and replaced
by your map:

<img src="../images/map_view_loaded.png" alt="Map view loaded" width="300"/>

### 5.1 ToolboxGUI

The demo app show a Toolbox GUI for configure behaviours and visual components displayed on the map.

Once modified, the new model could be injected into the current configuration. This demo shows only
some of the functions to be able to interact with the map control bar to enable or disable it,
change orientation, change the size of the buttons.

<img src="../images/map_view_toolbox.png" alt="Toolbox GUI for map view" width="300"/>



### 5.2 Map Listener

BlueGPSMapView could trigger your app remotely from the server. To handle an event click on the map,
it's necessary setup the listener.

```kotlin
private fun setListenerOnMapView() {
    binding.webView.setBlueGPSMapListener(object : BlueGPSMapListener {
        override fun resolvePromise(data: JavascriptCallback, typeMapCallback: TypeMapCallback) {
            /**
                * Callback that intercept the click on the map
                *
                * @param data the clicked point with all info.
                * @param typeMapCallback the type of the clicked point.
                *
                */
                when (typeMapCallback) {
                    
                    TypeMapCallback.INIT_SDK_COMPLETED -> { }   
                    TypeMapCallback.PARK_CONF -> { }
                    TypeMapCallback.MAP_CLICK, TypeMapCallback.TAG_CLICK -> { 
                        val cType = object : TypeToken<Position>() {}.type
                        val payloadResponse = Gson().fromJson<Position>(data.payload, cType)
                        
                        if (payloadResponse.roomId != null) {
                            // is a room
                        } else if (payloadResponse.tagid != null) {
                            // is a tag
                        }
                    }
                    TypeMapCallback.BOOKING_CLICK -> {
                        val cType = object : TypeToken<ClickedObject>() {}.type
                        val payloadResponse = Gson().fromJson<ClickedObject>(data.payload, cType)
                        Log.d(TAG, " $TAG $payloadResponse ") 
                    }
                    TypeMapCallback.NAV_STATS -> {
                        val cType = object : TypeToken<NavigationStats>() {}.type
                        val payloadResponse = Gson().fromJson<NavigationStats>(data.payload, cType)
                        Log.d(TAG, " $TAG $payloadResponse ")
                    }
                    TypeMapCallback.NAV_INFO -> {
                        val cType = object : TypeToken<NavInfo>() {}.type
                        val payloadResponse = Gson().fromJson<NavInfo>(data.payload, cType)
                        Toast.makeText(context, "${payloadResponse.message}", Toast.LENGTH_LONG).show()
                    }
                    TypeMapCallback.RESORUCE -> {
                        val cType = object : TypeToken<DataFilter>() {}.type
                        val payloadResponse = Gson().fromJson<DataFilter>(data.payload, cType)
                        Log.d(TAG, " $TAG $payloadResponse ")
                    }
                    TypeMapCallback.TAG_VISIBILITY -> {
                        val cType = object : TypeToken<TagVisibility>() {}.type
                        val payloadResponse = Gson().fromJson<TagVisibility>(data.payload, cType)
                        Log.d(TAG, " $TAG $payloadResponse ")
                    }
                    TypeMapCallback.ROOM_ENTER -> {
                        val cType = object : TypeToken<Position>() {}.type
                        val payloadResponse = Gson().fromJson<Position>(data.payload, cType)
                        Log.d(TAG, " $TAG $payloadResponse ")
                    }
                    TypeMapCallback.ROOM_EXIT -> {
                        val cType = object : TypeToken<Position>() {}.type
                        val payloadResponse = Gson().fromJson<Position>(data.payload, cType)
                        Log.d(TAG, " $TAG $payloadResponse ")
                    }
                    TypeMapCallback.FLOOR_CHANGE -> {
                        val cType = object : TypeToken<Floor>() {}.type
                        val payloadResponse = Gson().fromJson<Floor>(data.payload, cType)
                        Log.d(TAG, " $TAG $payloadResponse ")
                    }
                    TypeMapCallback.SUCCESS -> {
                        val cType = object : TypeToken<GenericInfo>() {}.type
                        val payloadResponse = Gson().fromJson<GenericInfo>(data.payload, cType)
                        payloadResponse.key = data.key
                        Log.d(TAG, " ${payloadResponse.message} ")
                    }
                    TypeMapCallback.ERROR -> {
                        val cType = object : TypeToken<GenericInfo>() {}.type
                        val payloadResponse = Gson().fromJson<GenericInfo>(data.payload, cType)
                        payloadResponse.key = data.key
                        Log.e(TAG, " ${payloadResponse.message} ")
                    }
            }
        }
    })
}
```

Once implemented, you can easily test receiving remote events by tapping on a room, or a tag in your
app.

The `resolvePromise(::)` method should be triggered appropriately.

List of the callbacks:
- `TypeMapCallback.INIT_SDK_COMPLETED` triggered when init sdk is completed.
- `TypeMapCallback.PARK_CONF` triggered if show.park is enabled.
- `TypeMapCallback.BOOKING_CLICK` triggered if a bookable resource is clicked.
- `TypeMapCallback.NAV_STATS` triggered on any navigation update.
- `TypeMapCallback.NAV_INFO` triggered on navigation mode when tag is proximity to specific. points. 
- `TypeMapCallback.RESORUCE` triggered when loadGenericResource is called.
- `TypeMapCallback.TAG_VISIBILITY` triggered if ConfigurationMap.tagid is present and the tag change its visibility status.
- `TypeMapCallback.ROOM_ENTER` triggered when user enter a room.
- `TypeMapCallback.ROOM_EXIT` triggered when user exit a room.
- `TypeMapCallback.FLOOR_CHANGE` triggered when the user change floor.
- `TypeMapCallback.SUCCESS` triggered when a generic async action end with success.
- `TypeMapCallback.ERROR` triggered when a generic async action end with error.



## 5.3 Map Interactions

BlueGPSMapView support multiple interactions that could be triggered programmatically from the code.

### 5.3.1 resetView

```kotlin
mapView.resetView()
```

This action resize the map to the startup. The action is present on the map toolbox.

### 5.3.2 rotate

```kotlin
mapView.rotate(step: Int)
```

This action rotate the map by adding step to current location. `step` represent the incremental
number of degree to rotate the map.

### 5.3.3 rotateAbsolute

```kotlin
mapView.rotateAbsolute(angle: Int)
```

his action set the angle rotation of the map according to the parameter. `angle` represent the
absolute number of degree to rotate the map.

### 5.3.4 hideRoomLayer

```kotlin
mapView.hideRoomLayer(hide: Boolean)
```

This action allow to show or hide the room layer. `hide` if true hide the layer, false otherwise.

### 5.3.5 nextFloor

```kotlin
mapView.nextFloor()
```

This action allow to load the next floor on the web view.

### 5.3.6 showTag

```kotlin
mapView.showTag(tagid: String, follow: Boolean)
```

This action find the tag with the specified tagid and if found switch to the right floor and follow
the tag if `follow` is true.

### 5.3.7 getFloor

```kotlin
mapView.getFloor() { result, error ->
    error?.let {
        Log.e(TAG, "$error")
    } ?: run {
        MaterialAlertDialogBuilder(this@MapActivity)
            .setTitle("Floor list")
            .setMessage(result.toString())
            .setPositiveButton("Ok") { dialog, _ ->
                dialog.dismiss()
            }
            .show()
    }
}
```

Return the list of floors, in the form of [Floor].

### 5.3.8 gotoFloor

```kotlin
mapView.gotoFloor(floor: Floor)
```

Move the map to the specified Floor.

### 5.3.9 gotoFromMe

```kotlin
mapView.gotoFromMe(
    position: Position, 
    navigationMode: Boolean = false)
```

This function enable path drawing for a specific destination. The path drawing will from the user
position to the selected destination position.

`navigationMode`: if true, draw the path in navigation mode.

### 5.3.10 goto

```kotlin
mapView.goto(
    source: Position, 
    dest: Position, 
    navigationMode: Boolean = false)
```

This function enable path drawing for a specific destination. The path drawing will from the source
position to the selected destination position.

`navigationMode`: if true, draw the path in navigation mode.

### 5.3.11 getMapStyle

```kotlin
mapView.getMapStyle() {result, error ->
    error?.let {
        Log.e(TAG, "$error")
    } ?: run {
        Log.d(TAG, "$result")
    }
}
```

This function get the actual style configuration.

### 5.3.12 setMapStyle

```kotlin
mapView.setMapStyle(style: MapStyle)
```

`style`: represent the map style object

This function allow to change the map style, the function overwrite only the attribute present.

### 5.3.13 setStartBookingDate

```kotlin
mapView.setStartBookingDate(date: String? = today)
```

`date`: BASIC_ISO string in format yyyy-MM-dd (ex. 2021-08-30), if not present dafault is today.

This function allow to set the start of booking selection, by default is today.

### 5.3.14 setBookingDate

```kotlin
mapView.setBookingDate(date: String)
```

`date`: BASIC_ISO string in format yyyy-MM-dd (ex. 2021-08-30).

This function allow to set the booking selection.

### 5.3.15 reloadResource

```kotlin
mapView.reloadResource(date: String)
```

`date`: BASIC_ISO string in format yyyy-MM-dd (ex. 2021-08-30).

This function reload the map view.

### 5.3.16 removeNavigation

```kotlin
mapView.removeNavigation()
```

This function exit from navigation and remove path either on navigation mode or not.

### 5.3.17 loadGenericResource

```kotlin
mapView.loadGenericResource(search: String? = "", type: String? = "", sybtype: String? = "")
```

- `search`: the resource name
- `type`: of the resource
- `subtype` of the resource

This function load only resource that match the criteria passed by parameters.

### 5.3.18 selectPoi

```kotlin
mapView.selectPoi(poi: GenericResource, changeFloor: Boolean? = true)
```

- `poi`: generic resource
- `changeFloor`: optional parameter with default value to true

Center the map to the poi passed as parameter.

### 5.3.19 selectPoiById

```kotlin
mapView.selectPoiById(poiId: Int, changeFloor: Boolean? = true)
```

- `poiId`: id of the poi
- `changeFloor`: optional parameter with default value to true

Center the map to the poi identified by poiId.

### 5.3.20 drawPin

```kotlin
mapView.drawPin(position: Position, icon: String? = "")
```

- `position`: object position
- `icon`: a String the represent absolute or relative path to the icon.

Draw a pin in the passed position. The pin has the icon passed as parameter.

### 5.3.21 getCurrentFloor

```kotlin
mapView.getCurrentFloor()
```

Return the current floor.

### 5.3.22 centerToRoom

```kotlin
mapView.centerToRoom(roomId: Int)
```

`roomId` the id of the room

Center the map to the room identified by roomId.

### 5.3.23 centerToPosition

```kotlin
mapView.centerToPosition(mapPosition: Position, zoom: Double)
```

- `mapPosition` the object position
- `zoom` the zoom level. The range is a double [0.7, 10]

Center the map to the specified position.

### 5.3.24 initAllBookingLayerBy

```kotlin
mapView.initAllBookingLayerBy(bookFilter: BookFilter)
```

- `bookFilter` a book filter

Init on map all booking layer like: Desk, Park, Meeting.

### 5.3.25 setDarkMode

```kotlin
mapView.setDarkMode(darkMode: Boolean)
```

- `darkMode` a boolean

To change the style of the map darkMode or lightMode



## 6. Server Sent Events

The purpose of diagnostic API is to give an indication to the integrator of the status of the
BlueGPS system.

The diagnostic is designed to include different info like:

- Tag tracking status

- Connector tracking status like:
    - DesigoCC
    
    - Micronpass
    
    - Quuppa
    
      

### 6.1 Diagnostic SSE

For diagnostic if a tag is `ACTIVE` or `NOT_ACTIVE`, `BlueGPSLib` expose a specific call `startDiagnostic(..)` where:
- `diagnosticSseRequest` is a list of tags; 
- `onComplete` callback; 
- and optional `onTagTracking` and `onCheck` callbacks.

```kotlin
val diagnosticSseRequest = DiagnosticSseRequest(
    TrackingSseRequest(tags = listOf("BBBB00000001", "BBBB00000002"))
)

BlueGPSLib.instance.startDiagnostic(
    diagnosticSseRequest = diagnosticSseRequest,
    onComplete = {
        // is a DiagnosticSseResponse
        Log.d(TAG, "COMPLETE: $it")
    },
    onTagTracking = {
        // is a Map<String, DiagnosticStatus>?
        Log.d(TAG, "TAG_TRACKING: $it")
    },
    onCheck = {
        // is a String
        Log.d(TAG, "CHECK: $it")
    }
)
```

`diagnosticSseRequest` is an object so structured:

```kotlin
class DiagnosticSseRequest(
    val tagTracking: TrackingSseRequest? = null
)

class TrackingSseRequest(
    val forgetTagMillis: Long? = 10000,
    val tags: List<String>? = null,
)
```

where

- `forgetTagMillis` is default to 10 seconds;
- `tags` is a list of tags you want to monitoring.

There are 2 types of events:

### Event `complete`

This event is returned as the first event and `DiagnosticSseResponse` object has the following format:

```
    data: {"tracking":{"tags":{"BBBB00000001":"NOT_ACTIVE"}}}
    name: "complete"
```

### Event `tagTracking`

This event is returned when there is an update on list of tags:

```
    data: {"BBBB00000001":"ACTIVE"}
    name: "tagTracking"
```

The `data` response is a `Map<String, DiagnosticStatus>`.

### Event `onCheck`

This event is a check that notifies that the diagnostic is alive.

### stopDiagnostic

`BlueGPSLib` expose an accessory method for deactivate the diagnostic.

```kotlin
BlueGPSLib.instance.stopDiagnostic()
```



> If during the life of the app it's necessary change the configuration it will be enough to call `startDiagnostic(..)`
because this method stop a previously job active and start the diagnostic with the new configuration. 



For more info check the example app in `SseDiagnosticTagActivity.kt` class.



### 6.2 Notify region changes

For activate the position event detection when the user move inside building,
`BlueGPSLib` expose a specific call `startNotifyRegionChanges(..)` where the params of this function are:
- `tags` a list of tags to monitoring;
- `regions` represents the list of the regions to monitor;
- and a `callbackHandler` callback that return a map that contains the regions where the tags are currently located.

```kotlin
BlueGPSLib.instance.startNotifyRegionChanges(
    tags = listOf(element = "010001010007"),
    regions = regions,
    callbackHandler = { it: Map<String, MutableList<BGPRegion>> ->
        
    }
)
```



#### 6.2.1 Event `callbackHandler`

This callback return a value when an event occurred. The object `BGPRegion` has this structure:

```kotlin
data class BGPRegion(
    val id: Int? = null,
    val name: String? = null,
    val buildingFloorId: Int? = null,
    val buildingFloorName: String? = null,
    val px: Double? = null,
    val py: Double? = null,
    val showOnApp: Boolean? = null,
    val searchable: Boolean? = null,
    val status: BGPRegionStatus? = null,
    val type: String? = null,
    val areaId: Int? = null,
    val areaName: String? = null,
    val area: BGPArea? = null,
    var isInside: Boolean = false,
)
```

> **Attention:** 

Before call `startNotifyRegionChanges()` it's necessary to call

```kotlin
blueGPSAdvertisingService?.startAdv()
```

or

```kotlin
blueGPSAdvertisingService?.startAdv(androidAdvConfiguration = androidAdvConfiguration!!)
```

because when advertising service is started a `tagID` is assigned to the app.



#### 6.2.2 Stop notify region changes

`BlueGPSLib` expose an accessory method for deactivate the Notify region job.

```kotlin
BlueGPSLib.instance.stopNotifyRegionChanges()
```



> If during the life of the app it's necessary change the configuration it will be enough to re-call `startNotifyRegionChanges(..)`
because this method stop a previously job active and start the event detection with the new configuration.



For more info check the example app in `NotifyRegionActivity.kt` class.



### 6.3 Notify position changes

For activate the position event detection when the user move inside building,
`BlueGPSLib` expose a specific call `startNotifyPositionChanges()` where the params of this function are:
- and a `callbackHandler` callback.

```kotlin
BlueGPSLib.instance.startNotifyPositionChanges(
    callbackHandler = {
        Log.d(TAG, "$position ${it}")
    }
)
```



#### 6.3.1 Event `callbackHandler`

This callback return a value when an event occurred. The object returned `Position` has this structure:

```kotlin
data class Position(
    var mapId: Int? = null,
    var tagid: String? = null,
    var roomId: Int? = null,
    var areaId: Int? = null,
    var x: Double? = null,
    var y: Double? = null,
    var data: String? = null,
    var tagLabel: String? = null,
)
```



#### 6.3.2 Stop notify position changes

`BlueGPSLib` expose an accessory method for deactivate the Notify position job.

```kotlin
BlueGPSLib.instance.stopNotifyPositionChanges()
```



> If during the life of the app it's necessary change the configuration it will be enough to re-call `startNotifyPositionChanges(..)`
because this method stop a previously job active and start the event detection with the new configuration.



For more info check the example app in `NotifyPositionActivity.kt` class.




## 7 Resources API

The BlueGPSLib perform a network call to find a list of resources. 

```kotlin
    override suspend fun findResources(
        isDesc: Boolean?,
        mapId: Int?,
        order: String?,
        search: String?,
        subType: String?,
        type: String?,
        roomId: Int?,
        roomName: String?
    ): Resource<List<GenericResource>?>
```

where

- `isDesc` a boolean that represent if is increasing or decreasing
- `mapId` the id of the map where the resource is located
- `order` 
- `search` the name of the resource
- `subType`
- `type` the resource type (`PARK`, `DESK`, `MEETING`)
- `roomId` the id of the room where the resource is located
- `roomName` the name of the room where the resource is located

It's present an example activity called `ShowResourcesActivity.kt` that show the utility and the use of this network call.

<img src="../images/search_resources_view.png" alt="Search View" width="300"/>





## 8 Search object API

BlueGPSSDK provides some built-in capabilities to search for resources and objects within the Backend, providing multiple calls:

### 8.1 getTrackElement

**getTrackElement** returns a tracked element by passing a corresponding **ID**.

```kotlin
suspend fun getTrackElement(trackElementId)
```

The resulting **ResponseMessage** contains a `TrackedElement` as follow:

```kotlin
data class TrackedElement(
    var id: Int?,
    var label: String?,
    var type: String?,
    var description: String?,
    var imgPath: String?,
    var color: String?,
    var trackElementType: TrackElementType?,
    var groups: List<TrackedGroup>?,
    var trackAreaId: Int?,
    var positionItem: PositionItem?,
    var tagList: List<TrackElementTag>?,
)
```

### 8.2 getTrackElementTagHistory

**getTrackElementTagHistory** returns a tag history passing a corresponding **ID**.

```kotlin
suspend fun getTrackElementTagHistory(trackElementId: Int)
```

The resulting **ResponseMessage** contains a list of `List<TrackElementTag>` as follow:

```kotlin
data class TrackElementTag(
    var id: Int?,
    var insertDate: String?,
    var readOnly: Boolean = true,
    var end: String?,
    var start: String?,
    var priority: Int?,
    var trackElementId: Int?,
    var trackElementLabel: String?,
    var trackTagId: String?,
    var trackTagLabel: String?,
)
```

### 8.3 getTrackElements

**getTrackElements** return an array of `TrackElement` based on the filter criteria specified.

```kotlin
suspend fun getTrackElements(
    type: String? = null,
    groupIds: List<Int>? = null,
    search: String? = null,
    isDesc: Boolean? = null,
    order: String? = null,
)
```

where:

- `search` is the name of the track element
- `type` 
- `groupIds` a list of id that represent the group
- `isDesc` a boolean that represent if is increasing or decreasing
- `order` a string that represent the order by a attribute
- `pageNumber` an that represent the current page
- `pageSize` the elements of the page

The resulting **ResponseMessage** contains a `List<TrackElement>` as follow:

```kotlin
data class TrackElement(
    var id: Int? = null,
    var label: String? = null,
    var type: String? = null,
    var description: String? = null,
    var imgPath: String? = null,
    var email: String? = null,
    var color: String? = null,
    var trackElementType: TrackElementType? = null,
    var groups: List<TrackedGroup>? = null,
    var positionItem: PositionItem? = null
)
```


### 8.4 getTrackElementPage

**getTrackElementPage** return a track element page based on the filter criteria specified.

```kotlin
suspend fun getTrackElementPage(
    type: String? = null,
    groupIds: List<Int>? = null,
    search: String? = null,
    isDesc: Boolean? = null,
    order: String? = null,
)
```

where:

- `search` is the name of the track element
- `type` 
- `groupIds` a list of id that represent the group
- `isDesc` a boolean that represent if is increasing or decreasing
- `order` a string that represent the order by a attribute

The resulting **ResponseMessage** contains a `PageTrackedElement` as follow:

```kotlin
class PageTrackedElement(
    var content: List<TrackedElement>,
    var numberOfElements: Int?,
    var first: Boolean,
    var last: Boolean,
    var totalElements: Int?,
    var totalPages: Int?,
)
```


### 8.5. getTrackGroup

**getTrackGroup** return a list of track group based on the filter criteria specified.

```kotlin
suspend fun getTrackGroup()
```

The resulting **ResponseMessage** contains a list of `List<TrackedGroup>` as follow:

```kotlin
data class TrackedGroup(
    var id: Int? = null,
    var label: String? = null,
    var type: String? = null,
    var color: String? = null,
)
```


### 8.6 getTrackTagByNfcCode

Get Tag list filtering by NFC code

```kotlin
suspend fun getTrackTagByNfcCode(
    search: String? = null,
    tagId: String? = null,
    label: String? = null,
    nfcCode: String? = null,
) : Resource<List<TrackTag>>
```

The resulting **ResponseMessage** contains a list of `List<TrackTag>` as follow:

```kotlin
data class TrackTag(
    var tagid: String? = null,
    var label: String? = null,
    var color: String? = null,
    var nfcCode: String? = null,
    var type: String? = null
)
```



## 9 Controllable items API

BlueGPSSDK provides a logic to interact with controllable items exposed by the backend.

Controllable items could be anything that can be remote controlled by the application.

Authenticated user could get the list of available items with the following call:

```kotlin
suspend fun BlueGPSLib.getControllableItems(itemControllableFilter: ItemControllableFilter? = null)
```

You can pass an optional filter criteria as follow:

```kotlin
data class ItemControllableFilter(
    ///full search on Item.logicName
    var logicName: String? = null,
    ///Search the item into a specified area
    var areaId: Int? = null,
    ///Search the item connected to a specified room
    var roomId: Int? = null,
    ///Search the item connected to a specified map
    var mapId: Int? = null,
    //Filter the item inside reference point from the radius
    var referencePoint: Position? = null,
    //Must be combined with referencePoint
    var radius: Double? = null,
    ///Select items of following types
    var types: List<ControllableElementType>? = null,
    var hasPosition: Boolean? = null,
    var widgetNames: List<String>? = null
)
```

The resulting `ResponseMesssage` contains a list of `List<ItemControllable>` as follow:

```kotlin
data class ItemControllable(
    var id: String,

    ///Internal name of the item
    var logicName: String,

    ///Internal name of the widget connected to the item
    var widgetName: String,

    ///name of this item
    var name: String?,

    ///internationalization key of this item
    var i18nName: String?,

    ///type of the current item
    var type: ControllableElementType,

    var position: Position?,

    var buildingPositionList: List<BuildingPosition>?,

    var icon: MobileIcon?,

    var controls: List<ItemControl>?
)
```

The attribute `controls` contains all the available controllable items for this specific `ItemControllable`.

Every `ItemControl`, could be changed, by modifying its `currentValue` property.

Then, you can call the below function to save new current value.

```kotlin
suspend fun BlueGPSLib.setControllableItem(itemCurrentValue: ItemCurrentValue)
```

The resulting `response` contains a resource of `ItemCurrentValue` as follow:

```kotlin
data class ItemCurrentValue(
    var id: Int = -1,
    var value: String?
)
```



## 10 Area API

BlueGPSSDK provides some built-in capabilities for rooms and areas.

### 10.1 getRoomsCoordinates

**getRoomsCoordinates** returns a list of rooms and coordinates.

```kotlin
    suspend fun getRoomsCoordinates(): Response<List<BGPRegion>>
```

The resulting **ResponseMessage** contains a `List<BGPRegion>` as follow:

```kotlin
data class BGPRegion(
    val id: Int? = null,
    val name: String? = null,
    val buildingFloorId: Int? = null,
    val buildingFloorName: String? = null,
    val px: Double? = null,
    val py: Double? = null,
    val showOnApp: Boolean? = null,
    val searchable: Boolean? = null,
    val status: BGPRegionStatus? = null,
    val type: String? = null,
    val areaId: Int? = null,
    val areaName: String? = null,
    val area: BGPArea? = null,
    var isInside: Boolean = false,
)
```

### 10.2 getMapsList

**getMapsList** Return a list of maps.

```kotlin
    suspend fun getMapsList(
        search: String? = null,
        staticResourceTypeList: List<BGPResourceType>? = null,
        isDesc: Boolean? = null,
        order: String? = null,
    ): Response<List<BGPMap>>
```

where:

- `search` the name of the map
- `staticResourceTypeList` a list of `BGPResourceType`
- `isDesc` a boolean
- `order` for name

The resulting **ResponseMessage** contains a `List<BGPMap>` as follow:

```kotlin
data class BGPMap(
    val id: Int? = null,
    val label: String? = null,
    val type: String? = null,
    val order: Int? = null,
    val circleRadius: Double? = null,
    val name: String? = null,
    val orientation: BGPMapOrientation? = null,
    val ox: Double? = null,
    val oy: Double? = null,
    val s1x: Double? = null,
    val s1y: Double? = null,
    val s2x: Double? = null,
    val s2y: Double? = null,
    val scale: Double? = null,
    val distance: Double? = null,
    val fileMap: String? = null,
    val mapRefreshRate: Int? = null,
    val animationDurationMs: Int? = null,
    val northAngle: Double? = null,
    val primaryColor: String? = null,
    val viewWidth: Double? = null,
    val viewHeight: Double? = null,
    val badgeDistance: Double? = null,
    val coordNameList: List<String>? = null,
    val allCoord: List<String>? = null,
)
```

### 10.3 getAreasWithTagsInside

**getAreasWithTagsInside** returns a list of area with a list of inside tags

```kotlin
    suspend fun getAreasWithTagsInside(
        areaFilterRequest: AreaFilterRequest? = null,
    ): Response<List<BGPMap>>
```

where:

- `areaFilterRequest` an object that contains a list of areas id or maps id

The resulting **ResponseMessage** contains a `List<AreaWithTagsInside>` as follow:

```kotlin
data class AreaWithTagsInside(
    val id: Int? = null,
    val name: String? = null,
    val tagIds: List<String>? = null
)
```


### 10.4 getAreasList

**getAreasList** returns a list of areas

```kotlin
    suspend fun getAreasList(
        search: String? = null,
        type: String? = null,
        isDesc: Boolean? = null,
        order: String? = null,
    ): Resource<List<BGPArea>>
```

where:

- `search` the name of the area
- `type` `BGPAreaType` // DEFAULT,FILTER
- `isDesc` a Boolean
- `order` for name

The resulting **ResponseMessage** contains a `List<BGPArea>` as follow:

```kotlin
    data class BGPArea(
        val id: Int? = null,
        val color: String? = null,
        val type: BGPAreaType? = null,
        val name: String? = null,
        val points: List<BGPPoint>? = null,
        val rtlsMapId: Int? = null
    )
```

### 10.5 getAreaListRealtimeElement

**getAreaListRealtimeElement** returns a `RealtimeAreaElementResponse` that contains the list of areas where a realtime
element (Tag, Element, etc.) is located.

```kotlin
    suspend fun getAreaListRealtimeElement(
        realtimeAreaElementRequest: RealtimeAreaElementRequest
    ): Resource<RealtimeAreaElementResponse>
```

where:

- `realtimeAreaElementRequest` is

```kotlin
    data class RealtimeAreaElementRequest(
        val id: String, // the id of the realtime element to locate (Tag, Element, etc.,)
        val type: RealtimeElementType
    )
```

```kotlin
    enum class RealtimeElementType {
        TAGS,
        ELEMENT,
        MOBILE_USER,
        GROUP,
        ROOM,
        BUILD_ITEM,
        LOCATORS,
        EVENT,
        NAVIGATION_ELEMENT,
        RESOURCE,
    }
```

The resulting **ResponseMessage** contains a `RealtimeAreaElementResponse` as follow:

```kotlin
data class RealtimeAreaElementResponse(
    val id: String,
    val type: RealtimeElementType,
    val areas: List<BGPArea>,
    val areaIds: List<Int>
)
```




## 11 Booking API

BlueGPS_SDK provides some built-in capabilities for booking.

### 11.1 getAgendaDay

`getAgendaDay()` return the agenda for the selected element.

```kotlin
suspend fun getAgendaDay(
    id: String,
    type: String,
    date: String,
): Resource<DaySchedule> 
```

where

- `id` the id of the element to be find the day schedule
- `type` the type of the element to be find the day schedule
- `date` Example: "2022-01-22"

The resulting **ResponseMessage** contains a `DaySchedule` as follow:

```koltin
data class DaySchedule(
    /**
     * unique id
     */
    val id: String,

    /**
     * example: 2023-01-21
     */
    val date: String,

    /**
     * example: 08:00
     */
    val dayStart: String,

    /**
     * example: 18:00
     */
    val dayEnd: String,

    /**
     * the list of elements [ScheduleElement]
     */
    val scheduleElements: List<ScheduleElement>
)
```

### 11.2 getAgendaMy

`getAgendaMy()` return all agenda for the logged user.

```kotlin
suspend fun getAgendaMy(
    dateStart: String? = null,
    dateEnd: String? = null,
): Resource<DaySchedule> {}
```

where

- `dateStart` Example : 2022-01-22
- `dateEnd` Example : 2022-01-22

The resulting **ResponseMessage** contains a `DaySchedule`.


### 11.3 agendaFind

`agendaFind()` return the agenda for the selected elements and for the selected date.

```kotlin
suspend fun agendaFind(
    resourceAgendaRequest: ResourceAgendaRequest
): Resource<ResourceAgendaResponse> {}
```

where

- `resourceAgendaRequest` [ResourceAgendaRequest] is

```kotlin
data class ResourceAgendaRequest(
    val elements: List<GenericResource>,

    /**
     * example: 2023-01-21
     */
    val dateStart: String,

    /**
     * example: 2023-01-21
     */
    val dateEnd: String? = null
)
```

The resulting **ResponseMessage** contains a `DaySchedule`. 

```kotlin
data class ResourceAgendaResponse(
    /**
     * unique id
     */
    val id: String? = null,

    /**
     * the resource searched
     */
    val resource: GenericResource? = null,

    /**
     * example: 2023-01-21
     */
    val dateStart: String,

    /**
     * example: 2023-01-21
     */
    val dateEnd: String? = null,

    val days: List<DaySchedule>? = null
)
```


### 11.4 schedule

`schedule()` to schedule a resource as DESK, ROOM, PARK, etc..,

```kotlin
suspend fun schedule(
    scheduleRequest: ScheduleRequest
): Resource<ScheduleRequest>
```

where

- `scheduleRequest` [ScheduleRequest] is

```kotlin
data class ScheduleRequest(

    /**
     * the id of the element to schedule
     */
    val elementId: String? = null,

    /**
     * an optional name for the meeting
     */
    val meetingName: String? = null,

    /**
     * an optional note for the meeting
     */
    val meetingNote: String? = null,

    /**
     * a boolean to indicate if is a video conference
     */
    val videoConference: Boolean? = null,

    /**
     * example: 2023-01-21
     */
    val dayStart: String? = null,

    /**
     * example: 2023-01-21
     */
    val dayEnd: String? = null,

    /**
     * example: 08:00
     */
    val start: String? = null,

    /**
     * example: 18:00
     */
    val end: String? = null,

    /**
     * a list of attendees for the meeting
     */
    val attendees: List<MeetingAttendee>? = null,

    /**
     * the type of the schedule [RecurringType]
     */
    val recurring: RecurringType? = null,
)
```

The resulting **ResponseMessage** contains a `ScheduleRequest`.




## 12. Scan Beacon Service

The BlueGPS SDK provides a background service that enables system integrators to efficiently determine the location of application users within environments equipped with beacons.

The service continuously operates in the background and detects when a user enters or exits the range of a configured beacon. These events are determined by an internal positioning algorithm.

The SDK relies on a proprietary internal algorithm that uses specific metrics to evaluate beacon signals and accurately determine a userâ€™s position within a defined region.



### 12.1 Start beacon scan service

This function starts the a foreground service, enabling continuous scanning of nearby configured areas. Running as a foreground service ensures reliable detection of the user's position relative to configured beacons, even when the application is operating in the background.

**Important**: Before calling this, you must ensure the user has granted the necessary runtime permissions:
- `ACCESS_FINE_LOCATION`
- `ACCESS_COARSE_LOCATION`

If you target Android 12 or higher (SDK 31+) you must also request:
- `BLUETOOTH_SCAN` 
- `BLUETOOTH_CONNECT` 

For show notifications, you must also add:
- `POST_NOTIFICATIONS`

If you want to detect beacons in the background, you must also add:
- `ACCESS_BACKGROUND_LOCATION`

If you want to detect beacons in the background, you must also add this permission to your `AndroidManifest.xml`:

```xml
<uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
<uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
<uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
<uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
```

If permissions are not granted, the service may not start or may crash. 
The optional `onError` callback will be invoked with an error message if the initial permission check fails.

An optional `PendingIntent` for background beacon events. 
- If provided, beacon events will be delivered through this `PendingIntent` when the app is in the background or closed. 
- If set to `null`, beacon events will only be delivered while the app is in the foreground.


**Note:** The following is an example of a possible implementation:

```kotlin
 val beaconEventIntent = Intent(context, BeaconEventReceiver::class.java).apply {
    action = BlueGPSLib.ACTION_BEACON_EVENT // This is crucial for the receiver to work
}

val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE  // MUTABLE allows fillInIntent data
} else {
    PendingIntent.FLAG_UPDATE_CURRENT
}

val beaconEventPendingIntent = PendingIntent.getBroadcast(
    context,
    0,
    beaconEventIntent,
    pendingIntentFlags
)

BlueGPSLib.instance.startTrackingUserPosition(
    context,
    beaconEventPendingIntent,
    onError = { error ->
        Log.e("BeaconTracking", "Failed to start: $error")
    },
)
```



### 12.2 Stop beacon scan service

This function stops the running `BGPScanBeaconService`. 

This method should be invoked when user position tracking is no longer required in order to conserve battery and system resources, for example when the user logs out or explicitly disables the feature.

```kotlin
BlueGPSLib.instance.stopTrackingUserPosition(context)
```



### 12.3 Collect the data location

The `bgpBeaconLocationFlow` is a `SharedFlow` that emits `BeaconLocation` objects whenever the SDK detects that a user enters or exits the proximity of a configured region.

The `BeaconLocation` object contains:
- `id`: A unique identifier for the beacon location.
- `message`: A descriptive message for the event (e.g., "Office Area").
- `event`: The type of event, which will be either `BeaconEvent.ENTER` or `BeaconEvent.EXIT`.
- `data`: Optional additional data associated with the location.

You can collect this flow to react to proximity changes in your application.

```kotlin
BlueGPSLib.instance.bgpBeaconLocationFlow.collect { beaconLocation ->
    when (beaconLocation.event) {
        BeaconEvent.ENTER -> {
            Log.d("BeaconTracker", "Entered region: ${beaconLocation.message}")
            // e.g., Show a welcome notification
        }
    }
}
```



### 12.4 Beacon event receiver (optional)

To handle events emitted by the BlueGPS SDK and for example show a local notification to the user, 
a `BroadcastReceiver` must be implemented. 

**Note:** The following is an example of a possible implementation:

```kotlin
class BeaconEventReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        // Check for beacon event by action or presence of primitive beacon data
        val isBeaconEvent = intent.action == BlueGPSLib.ACTION_BEACON_EVENT ||
                intent.hasExtra("beacon_id")

        if (isBeaconEvent) {
            val beaconId = intent.getStringExtra("beacon_id")
            val beaconMessage = intent.getStringExtra("beacon_message")
            val beaconData = intent.getStringExtra("beacon_data")
            val beaconEventName = intent.getStringExtra("beacon_event_name")

            if (beaconId != null && beaconMessage != null) {
                Log.i(TAG, "Beacon event received: $beaconEventName at $beaconMessage")

                // Try to reconstruct a BeaconLocation from primitive data
                val reconstructedBeaconLocation = reconstructBeaconLocationFromPrimitives(
                    beaconId, beaconMessage, beaconData, beaconEventName
                )

                if (reconstructedBeaconLocation != null) {
                    showBeaconNotification(context, reconstructedBeaconLocation)
                } else {
                    Log.w(TAG, "Could not reconstruct BeaconLocation from primitive data")
                }
            } else {
                Log.e(TAG, "Invalid beacon data received")
            }
        } else {
            Log.w(TAG, "Received intent with unknown action: ${intent.action}")
        }
    }

    /**
     * Reconstructs a BeaconLocation object from primitive data.
     * This provides the best user experience by creating a full object instead of primitive notification.
     */
    private fun reconstructBeaconLocationFromPrimitives(
        beaconId: String,
        beaconMessage: String,
        beaconData: String?,
        beaconEventName: String?
    ): BeaconLocation? {
        return try {
            // Convert event name string back to BeaconEvent enum
            val beaconEvent = when (beaconEventName) {
                "ENTER" -> BeaconEvent.ENTER
                "EXIT" -> BeaconEvent.EXIT
                else -> null // Handle unknown event types gracefully
            }

            // Reconstruct the BeaconLocation object
            BeaconLocation(
                id = beaconId,
                message = beaconMessage,
                data = beaconData,
                event = beaconEvent
            )
        } catch (e: Exception) {
            Log.e(TAG, "Failed to reconstruct BeaconLocation from primitives", e)
            null
        }
    }
}
```

The receiver should be registered in the `AndroidManifest.xml` so that the Android system can wake the application and deliver events even when the app process is not running.

```xml
<receiver
    android:name=".BeaconEventReceiver"
    android:exported="false">
    <intent-filter>
        <action android:name="com.synapseslab.bluegps_sdk.ACTION_BEACON_EVENT" />
    </intent-filter>
</receiver>
```



### 12.5 Boot Completed Receiver (optional)

To restart the beacon scanning service after the device reboots, declare a dedicated `BroadcastReceiver`. 

This receiver listens for the standard system broadcast `ACTION_BOOT_COMPLETED` and triggers the initialization of the scanning service when the system startup is complete.

**Note:** The following is an example of a possible implementation:

```kotlin
class BootCompletedReceiver : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            Log.d("BootCompletedReceiver", "Boot completed event received. Restarting beacon scanning.")

            // To start the service for background events, we must provide it with a PendingIntent
            // that it can use to notify the app. This creates an intent that points to our
            // BeaconEventReceiver, which is responsible for showing the notification.
            val beaconEventIntent = Intent(context, BeaconEventReceiver::class.java).apply {
                action = BlueGPSLib.ACTION_BEACON_EVENT // Essential for proper action handling
            }
            val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE  // MUTABLE allows fillInIntent data
            } else {
                PendingIntent.FLAG_UPDATE_CURRENT
            }
            val beaconEventPendingIntent = PendingIntent.getBroadcast(
                context,
                0,
                beaconEventIntent,
                pendingIntentFlags
            )
            
            BlueGPSLib.instance.startTrackingUserPosition(
                context = context,
                pendingIntent = beaconEventPendingIntent,
                onError = { error ->
                    Log.e("BootCompletedReceiver", "Failed to start beacon tracking on boot: $error")
                }
            )
        } else {
            Log.d("BootCompletedReceiver", "Received non-boot intent: ${intent.action} - Ignoring")
        }
    }
}
```

Declare the `BootCompletedReceiver` in your `AndroidManifest.xml` to restart the service when the device reboots.

```xml
<receiver
    android:name=".BootCompletedReceiver"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED" />
    </intent-filter>
</receiver>
```

